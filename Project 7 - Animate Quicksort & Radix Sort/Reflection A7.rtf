{\rtf1\ansi\ansicpg1252\cocoartf1561
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;\red38\green38\blue38;\red0\green0\blue0;}
{\*\expandedcolortbl;;\cssrgb\c20000\c20000\c20000;\cssrgb\c0\c0\c0;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 Reflection Assignment #6\
\
Testing Approach: \
Radix Sort:\
 - We first wrote a method getMax that gets the max bomber in the array to be used for limiting how many digits required to sort. \
 - We then wrote a method countSort that sorts an array based on the digits in the place exp. This is applied iteratively for each place up to the max required to sort the largest number. \
The method first counts the number of occurrences of each gift of the integer array, then has count[i]  contain the sorted position of the digit in the output, then builds the output array which is sorted based on the digit at place exp. In the last step of the method, the initial array is now changed to the new sorted output array. \
 - The third method, and the purpose of this program is radix sort. Our radix sort method  uses the getMax method to get the number with the most digit places, and the count sort method to sort the numbers in the array.\
 - Our program also includes a print method for arrays, (in this case tested for small size array).  \
 - Our program also includes a isSorted method that check to see if the method is sorted. \
 - Our main method creates an array of 1M random integers between 0 and 2147483647, prints true if the array is already sorted, prints false if the array isn\'92t sorted, then applies the radixSort method and then prints true if the array is now sorted or false if the array is still not sorted, although it should be.\
\
AnimateQuickSort\
 - This method is supposed to animate the partition portion of the quick sort method. \
 - Our program first creates an ArrayList of random integers from 1 to 1000, then creates the grid pane to store all the elements for the stage. \
 - We then set up an action for the step button to increase the low and decrement the high and then swap the pivot with the list at high. Essentially this part of the step action goes through the general steps of the partition portion. \
 - The stage is then set up with the scene. \
 - Our main method launches the application. \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\sl288\slmult1\pardirnatural\partightenfactor0
\cf0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 Reflection:\
 - For the radix sort program, what was difficult was coming up with a solution to the basics radix sort like counting the instances of a number in a certain digit,  what we now have as countSort, how can we use countSort for our radix sort? \
 - What was difficult was getting one button to prompt the different steps/ functions of the partition process. \
 - We were able to get the partition working, however, we were unable to complete/ figure out the final steps of the javafx portion, specifically the use of button event handlers (for multiple uses).\cf2 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf3 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
\
}